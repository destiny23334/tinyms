## poll和channel

什么是Reactor模式

什么是Proactor模式

tinyms运行逻辑是怎样的

EventLoop是一个事件循环，所以单个线程只需要有一个EventLoop。
EventLoop最重要的工作就是loop函数
- 当监听的文件描述符没有事件发生，就阻塞
- 当监听的文件描述符有一些有事件发生，就调用一些函数处理事件

监听并获取有事件发生的文件描述符，这个工作交给了Poll来执行，所以一个EventLoop有一个poll。这个Poll和不太可能会被外面的其他什么东西用
Poll实际上是对Linux中epoll的一些封装

处理事件交给Channel去做。Channel是对文件描述符的抽象封装，我们可以很自然的想到，当监听的某个文件描述符发生了事件



channel作为事件处理的回调，需要保存当前channel对应的那个事件，以及当事件发生后
处理这个事件的函数。

在channel中，事件用文件描述符保存，而处理函数用一个函数对象保存。当然，这里的函数对象是需要上层注册

在TCP网络编程中，常用的事件可能就那么几种：
- 作为服务端 listen的时候有新的连接进来了
- 作为客户端或者服务端，套接字上有数据可read，或者可write了
- 在定时器中，有某个定时器到期了，需要执行任务了

Channel将所有事件抽象成了这几种
- 可读事件，比如服务端有新连接，客户端收到了服务端的消息
- 可写事件，在数据传输时，客户端或者服务端可写了
- 错误事件，这个没用过不知道。。

一个Channel只能所属于一个EventLoop。因为Channel对应了一个文件描述符

Poller是负责监听文件描述符上的事件的
调用Poller::poll来等待事件发生。poll的底层是使用epoll_wait。
